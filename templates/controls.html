<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>RPI-edge Dashboard</title>

    <!-- Custom fonts for this template-->
    <link href="../static/vendor/fontawesome-free/css/all.min.css" rel="stylesheet" type="text/css">
    <link
            href="https://fonts.googleapis.com/css?family=Nunito:200,200i,300,300i,400,400i,600,600i,700,700i,800,800i,900,900i"
            rel="stylesheet">

    <!-- Custom styles for this template-->
    <link href="../static/css/sb-admin-2.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://prismjs.com/themes/prism.css">
    <link rel="stylesheet" href="https://prismjs.com/plugins/line-numbers/prism-line-numbers.css">
    <link rel="stylesheet" href="../static/css/prism-live.css">
    <link rel="stylesheet" href="../static/css/style.css">

</head>


<script>
    //window.onload = setInterval(random_data, 1000);

    function set_data(type) {
        if (type === 'fan') {
            var fan = document.getElementById('fan-control').value;
            var fan_text = document.getElementById('fan-usage');
            var fan_icon = document.getElementById('fanicon');
            var color_fan = document.getElementById('fan-color').value;
            fan_icon.setAttribute("style", "color:" + color_fan.toString() + "; opacity: " + (fan / 100).toString() + ';');
            fan_text.textContent = fan.toString() + ' %';
        } else if (type === 'pump') {
            var pump = document.getElementById('pump-control').value;
            var pump_text = document.getElementById('pump-usage');
            var pump_icon = document.getElementById('pumpicon');
            var color_pump = document.getElementById('pump-color').value;
            pump_icon.setAttribute("style", "color:" + color_pump.toString() + "; opacity: " + (pump / 100).toString() + ';');
            pump_text.textContent = pump.toString() + ' %';
        }
    }
</script>

<body id="page-top">

<!-- Page Wrapper -->
<div id="wrapper">

    <!-- Sidebar -->
    <ul class="navbar-nav bg-gradient-primary sidebar sidebar-dark accordion" id="accordionSidebar">

        <!-- Sidebar - Brand -->
        <a class="sidebar-brand d-flex align-items-center justify-content-center" href="index">
            <div class="sidebar-brand-icon rotate-n-15">
                <i class="fas fa-fan"></i>
            </div>
            <div class="sidebar-brand-text mx-3">RPI-Edge Admin<sup>2</sup></div>
        </a>

        <!-- Divider -->
        <hr class="sidebar-divider my-0">

        <!-- Nav Item - Dashboard -->
        <li class="nav-item active">
            <a class="nav-link" href="index">
                <i class="fas fa-fw fa-tachometer-alt"></i>
                <span>Dashboard</span></a>
        </li>
        <li class="nav-item active">
            <a class="nav-link" href="controls">
                <i class="fas fa-fw fa-wrench"></i>
                <span>Controls</span></a>
        </li>

        <!-- Divider -->
        <hr class="sidebar-divider">

        <!-- Heading -->
        <div class="sidebar-heading">
            Interface
        </div>

        <!-- Nav Item - Charts -->
        <li class="nav-item">
            <a class="nav-link" href="charts">
                <i class="fas fa-fw fa-chart-area"></i>
                <span>Charts</span></a>
        </li>

        <!-- Divider -->
        <hr class="sidebar-divider d-none d-md-block">

        <!-- Sidebar Toggler (Sidebar) -->
        <div class="text-center d-none d-md-inline">
            <button class="rounded-circle border-0" id="sidebarToggle"></button>
        </div>
    </ul>
    <!-- End of Sidebar -->

    <!-- Content Wrapper -->
    <div id="content-wrapper" class="d-flex flex-column">

        <!-- Main Content -->
        <div id="content">

            <!-- Topbar -->
            <nav class="navbar navbar-expand navbar-light bg-white topbar mb-4 static-top shadow">

                <!-- Sidebar Toggle (Topbar) -->
                <button id="sidebarToggleTop" class="btn btn-link d-md-none rounded-circle mr-3">
                    <i class="fa fa-bars"></i>
                </button>

                <!-- Topbar Search -->
                <form
                        class="d-none d-sm-inline-block form-inline mr-auto ml-md-3 my-2 my-md-0 mw-100 navbar-search">
                    <div class="input-group">
                        <input type="text" class="form-control bg-light border-0 small" placeholder="Search for..."
                               aria-label="Search" aria-describedby="basic-addon2">
                        <div class="input-group-append">
                            <button class="btn btn-primary" type="button">
                                <i class="fas fa-search fa-sm"></i>
                            </button>
                        </div>
                    </div>
                </form>
                <div class="topbar-divider d-none d-sm-block"></div>

                <!-- Nav Item - User Information -->
                <li class="nav-item dropdown no-arrow">
                    <a class="nav-link dropdown-toggle" href="#" id="userDropdown" role="button"
                       data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                        <span class="mr-2 d-none d-lg-inline text-gray-600 small">Douglas McGee</span>
                        <img class="img-profile rounded-circle"
                             src="../static/img/undraw_profile.svg">
                    </a>
                    <!-- Dropdown - User Information -->
                    <div class="dropdown-menu dropdown-menu-right shadow animated--grow-in"
                         aria-labelledby="userDropdown">
                        <div class="dropdown-divider"></div>
                        <a class="dropdown-item" href="#" data-toggle="modal" data-target="#logoutModal">
                            <i class="fas fa-sign-out-alt fa-sm fa-fw mr-2 text-gray-400"></i>
                            Logout
                        </a>
                    </div>
                </li>

                </ul>

            </nav>
            <!-- End of Topbar -->

            <!-- Begin Page Content -->
            <div class="container-fluid">

                <!-- Page Heading -->
                <div class="d-sm-flex align-items-center justify-content-between mb-4">
                    <h1 class="h3 mb-0 text-gray-800">Dashboard</h1>
                    <a href="#" class="d-none d-sm-inline-block btn btn-sm btn-primary shadow-sm"><i
                            class="fas fa-download fa-sm text-white-50"></i> Generate Report</a>
                </div>


                <div class="text-xl-left font-weight-bold text-gray-900 text-uppercase mb-1">
                    RPi-0
                </div>

                <!-- Content Row -->
                <div class="row">
                    <!-- Fan speed controller -->
                    <div class="col-xl-3 col-md-6 mb-4">
                        <div class="card border-left-info shadow h-100 py-2">
                            <div class="card-body">
                                <div class="row no-gutters align-items-center">
                                    <div class="col mr-2">
                                        <div class="text-xs font-weight-bold text-info text-uppercase mb-1">Fan Speed
                                        </div>
                                        <div class="row no-gutters align-items-center">
                                            <div class="col-auto">
                                                <label for="fan-control"></label><input id="fan-control" type="range"
                                                                                        min="0" max="100" step="5"
                                                                                        onchange="set_data('fan')">
                                                <div id="fan-usage" class="h5 mb-0 mr-3 font-weight-bold text-gray-800">
                                                    50%
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="col-auto">
                                        <i id="fanicon" style="color: #ff0000; opacity: 0.5; "
                                           class="fas fa-solid fa-fan fa-2x"></i>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Pump Speed -->
                    <div class="col-xl-3 col-md-6 mb-4">
                        <div class="card border-left-info shadow h-100 py-2">
                            <div class="card-body">
                                <div class="row no-gutters align-items-center">
                                    <div class="col mr-2">
                                        <div class="text-xs font-weight-bold text-info text-uppercase mb-1">Fan Speed
                                        </div>
                                        <div class="row no-gutters align-items-center">
                                            <div class="col-auto">
                                                <label for="pump-control"></label><input id="pump-control" type="range"
                                                                                         min="0" max="100" step="5"
                                                                                         onchange="set_data('pump')">
                                                <div id="pump-usage"
                                                     class="h5 mb-0 mr-3 font-weight-bold text-gray-800">
                                                    50%
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="col-auto">
                                        <i id="pumpicon" style="color: #ff0000; opacity: 0.5; "
                                           class="fas fa-solid fa-fan fa-2x"></i>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- colorpicker -->
                    <div class="col-xl-3 col-md-6 mb-4">
                        <div class="card border-left-info shadow h-100 py-2">
                            <div class="card-body">
                                <div class="row no-gutters align-items-center">
                                    <div class="col mr-2">
                                        <div class="text-xs font-weight-bold text-info text-uppercase mb-1">Colors
                                        </div>
                                        <div class="row no-gutters align-items-center">
                                            <div class="col-auto" style="margin-right: 20px">
                                                <input id="fan-color" value="#ff0000" type="color"
                                                       oninput="set_data('fan')">
                                                <div style="color:#0a53be"> Fan Color</div>
                                            </div>
                                            <div class="col-auto">
                                                <input id="pump-color" value="#ff0000" type="color"
                                                       oninput="set_data('pump')">
                                                <div style="color:#0a53be"> Pump Color</div>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="col-auto">
                                        <i class="fas fa-bolt fa-2x text-gray-300"></i>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <!--Отправка кода/команд-->
                <div>
                    <script>var _self="undefined"!=typeof window?window:"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope?self:{},Prism=function(e){var n=/(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i,t=0,r={},a={manual:e.Prism&&e.Prism.manual,disableWorkerMessageHandler:e.Prism&&e.Prism.disableWorkerMessageHandler,util:{encode:function e(n){return n instanceof i?new i(n.type,e(n.content),n.alias):Array.isArray(n)?n.map(e):n.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/\u00a0/g," ")},type:function(e){return Object.prototype.toString.call(e).slice(8,-1)},objId:function(e){return e.__id||Object.defineProperty(e,"__id",{value:++t}),e.__id},clone:function e(n,t){var r,i;switch(t=t||{},a.util.type(n)){case"Object":if(i=a.util.objId(n),t[i])return t[i];for(var l in r={},t[i]=r,n)n.hasOwnProperty(l)&&(r[l]=e(n[l],t));return r;case"Array":return i=a.util.objId(n),t[i]?t[i]:(r=[],t[i]=r,n.forEach((function(n,a){r[a]=e(n,t)})),r);default:return n}},getLanguage:function(e){for(;e;){var t=n.exec(e.className);if(t)return t[1].toLowerCase();e=e.parentElement}return"none"},setLanguage:function(e,t){e.className=e.className.replace(RegExp(n,"gi"),""),e.classList.add("language-"+t)},currentScript:function(){if("undefined"==typeof document)return null;if("currentScript"in document)return document.currentScript;try{throw new Error}catch(r){var e=(/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(r.stack)||[])[1];if(e){var n=document.getElementsByTagName("script");for(var t in n)if(n[t].src==e)return n[t]}return null}},isActive:function(e,n,t){for(var r="no-"+n;e;){var a=e.classList;if(a.contains(n))return!0;if(a.contains(r))return!1;e=e.parentElement}return!!t}},languages:{plain:r,plaintext:r,text:r,txt:r,extend:function(e,n){var t=a.util.clone(a.languages[e]);for(var r in n)t[r]=n[r];return t},insertBefore:function(e,n,t,r){var i=(r=r||a.languages)[e],l={};for(var o in i)if(i.hasOwnProperty(o)){if(o==n)for(var s in t)t.hasOwnProperty(s)&&(l[s]=t[s]);t.hasOwnProperty(o)||(l[o]=i[o])}var u=r[e];return r[e]=l,a.languages.DFS(a.languages,(function(n,t){t===u&&n!=e&&(this[n]=l)})),l},DFS:function e(n,t,r,i){i=i||{};var l=a.util.objId;for(var o in n)if(n.hasOwnProperty(o)){t.call(n,o,n[o],r||o);var s=n[o],u=a.util.type(s);"Object"!==u||i[l(s)]?"Array"!==u||i[l(s)]||(i[l(s)]=!0,e(s,t,o,i)):(i[l(s)]=!0,e(s,t,null,i))}}},plugins:{},highlightAll:function(e,n){a.highlightAllUnder(document,e,n)},highlightAllUnder:function(e,n,t){var r={callback:t,container:e,selector:'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'};a.hooks.run("before-highlightall",r),r.elements=Array.prototype.slice.apply(r.container.querySelectorAll(r.selector)),a.hooks.run("before-all-elements-highlight",r);for(var i,l=0;i=r.elements[l++];)a.highlightElement(i,!0===n,r.callback)},highlightElement:function(n,t,r){var i=a.util.getLanguage(n),l=a.languages[i];a.util.setLanguage(n,i);var o=n.parentElement;o&&"pre"===o.nodeName.toLowerCase()&&a.util.setLanguage(o,i);var s={element:n,language:i,grammar:l,code:n.textContent};function u(e){s.highlightedCode=e,a.hooks.run("before-insert",s),s.element.innerHTML=s.highlightedCode,a.hooks.run("after-highlight",s),a.hooks.run("complete",s),r&&r.call(s.element)}if(a.hooks.run("before-sanity-check",s),(o=s.element.parentElement)&&"pre"===o.nodeName.toLowerCase()&&!o.hasAttribute("tabindex")&&o.setAttribute("tabindex","0"),!s.code)return a.hooks.run("complete",s),void(r&&r.call(s.element));if(a.hooks.run("before-highlight",s),s.grammar)if(t&&e.Worker){var c=new Worker(a.filename);c.onmessage=function(e){u(e.data)},c.postMessage(JSON.stringify({language:s.language,code:s.code,immediateClose:!0}))}else u(a.highlight(s.code,s.grammar,s.language));else u(a.util.encode(s.code))},highlight:function(e,n,t){var r={code:e,grammar:n,language:t};if(a.hooks.run("before-tokenize",r),!r.grammar)throw new Error('The language "'+r.language+'" has no grammar.');return r.tokens=a.tokenize(r.code,r.grammar),a.hooks.run("after-tokenize",r),i.stringify(a.util.encode(r.tokens),r.language)},tokenize:function(e,n){var t=n.rest;if(t){for(var r in t)n[r]=t[r];delete n.rest}var a=new s;return u(a,a.head,e),o(e,a,n,a.head,0),function(e){for(var n=[],t=e.head.next;t!==e.tail;)n.push(t.value),t=t.next;return n}(a)},hooks:{all:{},add:function(e,n){var t=a.hooks.all;t[e]=t[e]||[],t[e].push(n)},run:function(e,n){var t=a.hooks.all[e];if(t&&t.length)for(var r,i=0;r=t[i++];)r(n)}},Token:i};function i(e,n,t,r){this.type=e,this.content=n,this.alias=t,this.length=0|(r||"").length}function l(e,n,t,r){e.lastIndex=n;var a=e.exec(t);if(a&&r&&a[1]){var i=a[1].length;a.index+=i,a[0]=a[0].slice(i)}return a}function o(e,n,t,r,s,g){for(var f in t)if(t.hasOwnProperty(f)&&t[f]){var h=t[f];h=Array.isArray(h)?h:[h];for(var d=0;d<h.length;++d){if(g&&g.cause==f+","+d)return;var v=h[d],p=v.inside,m=!!v.lookbehind,y=!!v.greedy,k=v.alias;if(y&&!v.pattern.global){var x=v.pattern.toString().match(/[imsuy]*$/)[0];v.pattern=RegExp(v.pattern.source,x+"g")}for(var b=v.pattern||v,w=r.next,A=s;w!==n.tail&&!(g&&A>=g.reach);A+=w.value.length,w=w.next){var E=w.value;if(n.length>e.length)return;if(!(E instanceof i)){var P,L=1;if(y){if(!(P=l(b,A,e,m))||P.index>=e.length)break;var S=P.index,O=P.index+P[0].length,j=A;for(j+=w.value.length;S>=j;)j+=(w=w.next).value.length;if(A=j-=w.value.length,w.value instanceof i)continue;for(var C=w;C!==n.tail&&(j<O||"string"==typeof C.value);C=C.next)L++,j+=C.value.length;L--,E=e.slice(A,j),P.index-=A}else if(!(P=l(b,0,E,m)))continue;S=P.index;var N=P[0],_=E.slice(0,S),M=E.slice(S+N.length),W=A+E.length;g&&W>g.reach&&(g.reach=W);var z=w.prev;if(_&&(z=u(n,z,_),A+=_.length),c(n,z,L),w=u(n,z,new i(f,p?a.tokenize(N,p):N,k,N)),M&&u(n,w,M),L>1){var I={cause:f+","+d,reach:W};o(e,n,t,w.prev,A,I),g&&I.reach>g.reach&&(g.reach=I.reach)}}}}}}function s(){var e={value:null,prev:null,next:null},n={value:null,prev:e,next:null};e.next=n,this.head=e,this.tail=n,this.length=0}function u(e,n,t){var r=n.next,a={value:t,prev:n,next:r};return n.next=a,r.prev=a,e.length++,a}function c(e,n,t){for(var r=n.next,a=0;a<t&&r!==e.tail;a++)r=r.next;n.next=r,r.prev=n,e.length-=a}if(e.Prism=a,i.stringify=function e(n,t){if("string"==typeof n)return n;if(Array.isArray(n)){var r="";return n.forEach((function(n){r+=e(n,t)})),r}var i={type:n.type,content:e(n.content,t),tag:"span",classes:["token",n.type],attributes:{},language:t},l=n.alias;l&&(Array.isArray(l)?Array.prototype.push.apply(i.classes,l):i.classes.push(l)),a.hooks.run("wrap",i);var o="";for(var s in i.attributes)o+=" "+s+'="'+(i.attributes[s]||"").replace(/"/g,"&quot;")+'"';return"<"+i.tag+' class="'+i.classes.join(" ")+'"'+o+">"+i.content+"</"+i.tag+">"},!e.document)return e.addEventListener?(a.disableWorkerMessageHandler||e.addEventListener("message",(function(n){var t=JSON.parse(n.data),r=t.language,i=t.code,l=t.immediateClose;e.postMessage(a.highlight(i,a.languages[r],r)),l&&e.close()}),!1),a):a;var g=a.util.currentScript();function f(){a.manual||a.highlightAll()}if(g&&(a.filename=g.src,g.hasAttribute("data-manual")&&(a.manual=!0)),!a.manual){var h=document.readyState;"loading"===h||"interactive"===h&&g&&g.defer?document.addEventListener("DOMContentLoaded",f):window.requestAnimationFrame?window.requestAnimationFrame(f):window.setTimeout(f,16)}return a}(_self);"undefined"!=typeof module&&module.exports&&(module.exports=Prism),"undefined"!=typeof global&&(global.Prism=Prism);
                    Prism.languages.markup={comment:{pattern:/<!--(?:(?!<!--)[\s\S])*?-->/,greedy:!0},prolog:{pattern:/<\?[\s\S]+?\?>/,greedy:!0},doctype:{pattern:/<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,greedy:!0,inside:{"internal-subset":{pattern:/(^[^\[]*\[)[\s\S]+(?=\]>$)/,lookbehind:!0,greedy:!0,inside:null},string:{pattern:/"[^"]*"|'[^']*'/,greedy:!0},punctuation:/^<!|>$|[[\]]/,"doctype-tag":/^DOCTYPE/i,name:/[^\s<>'"]+/}},cdata:{pattern:/<!\[CDATA\[[\s\S]*?\]\]>/i,greedy:!0},tag:{pattern:/<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,greedy:!0,inside:{tag:{pattern:/^<\/?[^\s>\/]+/,inside:{punctuation:/^<\/?/,namespace:/^[^\s>\/:]+:/}},"special-attr":[],"attr-value":{pattern:/=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,inside:{punctuation:[{pattern:/^=/,alias:"attr-equals"},{pattern:/^(\s*)["']|["']$/,lookbehind:!0}]}},punctuation:/\/?>/,"attr-name":{pattern:/[^\s>\/]+/,inside:{namespace:/^[^\s>\/:]+:/}}}},entity:[{pattern:/&[\da-z]{1,8};/i,alias:"named-entity"},/&#x?[\da-f]{1,8};/i]},Prism.languages.markup.tag.inside["attr-value"].inside.entity=Prism.languages.markup.entity,Prism.languages.markup.doctype.inside["internal-subset"].inside=Prism.languages.markup,Prism.hooks.add("wrap",(function(a){"entity"===a.type&&(a.attributes.title=a.content.replace(/&amp;/,"&"))})),Object.defineProperty(Prism.languages.markup.tag,"addInlined",{value:function(a,e){var s={};s["language-"+e]={pattern:/(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,lookbehind:!0,inside:Prism.languages[e]},s.cdata=/^<!\[CDATA\[|\]\]>$/i;var t={"included-cdata":{pattern:/<!\[CDATA\[[\s\S]*?\]\]>/i,inside:s}};t["language-"+e]={pattern:/[\s\S]+/,inside:Prism.languages[e]};var n={};n[a]={pattern:RegExp("(<__[^>]*>)(?:<!\\[CDATA\\[(?:[^\\]]|\\](?!\\]>))*\\]\\]>|(?!<!\\[CDATA\\[)[^])*?(?=</__>)".replace(/__/g,(function(){return a})),"i"),lookbehind:!0,greedy:!0,inside:t},Prism.languages.insertBefore("markup","cdata",n)}}),Object.defineProperty(Prism.languages.markup.tag,"addAttribute",{value:function(a,e){Prism.languages.markup.tag.inside["special-attr"].push({pattern:RegExp("(^|[\"'\\s])(?:"+a+")\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))","i"),lookbehind:!0,inside:{"attr-name":/^[^\s=]+/,"attr-value":{pattern:/=[\s\S]+/,inside:{value:{pattern:/(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,lookbehind:!0,alias:[e,"language-"+e],inside:Prism.languages[e]},punctuation:[{pattern:/^=/,alias:"attr-equals"},/"|'/]}}}})}}),Prism.languages.html=Prism.languages.markup,Prism.languages.mathml=Prism.languages.markup,Prism.languages.svg=Prism.languages.markup,Prism.languages.xml=Prism.languages.extend("markup",{}),Prism.languages.ssml=Prism.languages.xml,Prism.languages.atom=Prism.languages.xml,Prism.languages.rss=Prism.languages.xml;
                    !function(s){var e=/(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;s.languages.css={comment:/\/\*[\s\S]*?\*\//,atrule:{pattern:RegExp("@[\\w-](?:[^;{\\s\"']|\\s+(?!\\s)|"+e.source+")*?(?:;|(?=\\s*\\{))"),inside:{rule:/^@[\w-]+/,"selector-function-argument":{pattern:/(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,lookbehind:!0,alias:"selector"},keyword:{pattern:/(^|[^\w-])(?:and|not|only|or)(?![\w-])/,lookbehind:!0}}},url:{pattern:RegExp("\\burl\\((?:"+e.source+"|(?:[^\\\\\r\n()\"']|\\\\[^])*)\\)","i"),greedy:!0,inside:{function:/^url/i,punctuation:/^\(|\)$/,string:{pattern:RegExp("^"+e.source+"$"),alias:"url"}}},selector:{pattern:RegExp("(^|[{}\\s])[^{}\\s](?:[^{};\"'\\s]|\\s+(?![\\s{])|"+e.source+")*(?=\\s*\\{)"),lookbehind:!0},string:{pattern:e,greedy:!0},property:{pattern:/(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,lookbehind:!0},important:/!important\b/i,function:{pattern:/(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,lookbehind:!0},punctuation:/[(){};:,]/},s.languages.css.atrule.inside.rest=s.languages.css;var t=s.languages.markup;t&&(t.tag.addInlined("style","css"),t.tag.addAttribute("style","css"))}(Prism);
                    Prism.languages.clike={comment:[{pattern:/(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,lookbehind:!0,greedy:!0},{pattern:/(^|[^\\:])\/\/.*/,lookbehind:!0,greedy:!0}],string:{pattern:/(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,greedy:!0},"class-name":{pattern:/(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,lookbehind:!0,inside:{punctuation:/[.\\]/}},keyword:/\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,boolean:/\b(?:false|true)\b/,function:/\b\w+(?=\()/,number:/\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,operator:/[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,punctuation:/[{}[\];(),.:]/};
                    Prism.languages.javascript=Prism.languages.extend("clike",{"class-name":[Prism.languages.clike["class-name"],{pattern:/(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,lookbehind:!0}],keyword:[{pattern:/((?:^|\})\s*)catch\b/,lookbehind:!0},{pattern:/(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,lookbehind:!0}],function:/#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,number:{pattern:RegExp("(^|[^\\w$])(?:NaN|Infinity|0[bB][01]+(?:_[01]+)*n?|0[oO][0-7]+(?:_[0-7]+)*n?|0[xX][\\dA-Fa-f]+(?:_[\\dA-Fa-f]+)*n?|\\d+(?:_\\d+)*n|(?:\\d+(?:_\\d+)*(?:\\.(?:\\d+(?:_\\d+)*)?)?|\\.\\d+(?:_\\d+)*)(?:[Ee][+-]?\\d+(?:_\\d+)*)?)(?![\\w$])"),lookbehind:!0},operator:/--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/}),Prism.languages.javascript["class-name"][0].pattern=/(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/,Prism.languages.insertBefore("javascript","keyword",{regex:{pattern:RegExp("((?:^|[^$\\w\\xA0-\\uFFFF.\"'\\])\\s]|\\b(?:return|yield))\\s*)/(?:(?:\\[(?:[^\\]\\\\\r\n]|\\\\.)*\\]|\\\\.|[^/\\\\\\[\r\n])+/[dgimyus]{0,7}|(?:\\[(?:[^[\\]\\\\\r\n]|\\\\.|\\[(?:[^[\\]\\\\\r\n]|\\\\.|\\[(?:[^[\\]\\\\\r\n]|\\\\.)*\\])*\\])*\\]|\\\\.|[^/\\\\\\[\r\n])+/[dgimyus]{0,7}v[dgimyus]{0,7})(?=(?:\\s|/\\*(?:[^*]|\\*(?!/))*\\*/)*(?:$|[\r\n,.;:})\\]]|//))"),lookbehind:!0,greedy:!0,inside:{"regex-source":{pattern:/^(\/)[\s\S]+(?=\/[a-z]*$)/,lookbehind:!0,alias:"language-regex",inside:Prism.languages.regex},"regex-delimiter":/^\/|\/$/,"regex-flags":/^[a-z]+$/}},"function-variable":{pattern:/#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,alias:"function"},parameter:[{pattern:/(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,lookbehind:!0,inside:Prism.languages.javascript},{pattern:/(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,lookbehind:!0,inside:Prism.languages.javascript},{pattern:/(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,lookbehind:!0,inside:Prism.languages.javascript},{pattern:/((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,lookbehind:!0,inside:Prism.languages.javascript}],constant:/\b[A-Z](?:[A-Z_]|\dx?)*\b/}),Prism.languages.insertBefore("javascript","string",{hashbang:{pattern:/^#!.*/,greedy:!0,alias:"comment"},"template-string":{pattern:/`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,greedy:!0,inside:{"template-punctuation":{pattern:/^`|`$/,alias:"string"},interpolation:{pattern:/((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,lookbehind:!0,inside:{"interpolation-punctuation":{pattern:/^\$\{|\}$/,alias:"punctuation"},rest:Prism.languages.javascript}},string:/[\s\S]+/}},"string-property":{pattern:/((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,lookbehind:!0,greedy:!0,alias:"property"}}),Prism.languages.insertBefore("javascript","operator",{"literal-property":{pattern:/((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,lookbehind:!0,alias:"property"}}),Prism.languages.markup&&(Prism.languages.markup.tag.addInlined("script","javascript"),Prism.languages.markup.tag.addAttribute("on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)","javascript")),Prism.languages.js=Prism.languages.javascript;
                    !function(e){var n=/[*&][^\s[\]{},]+/,r=/!(?:<[\w\-%#;/?:@&=+$,.!~*'()[\]]+>|(?:[a-zA-Z\d-]*!)?[\w\-%#;/?:@&=+$.~*'()]+)?/,t="(?:"+r.source+"(?:[ \t]+"+n.source+")?|"+n.source+"(?:[ \t]+"+r.source+")?)",a="(?:[^\\s\\x00-\\x08\\x0e-\\x1f!\"#%&'*,\\-:>?@[\\]`{|}\\x7f-\\x84\\x86-\\x9f\\ud800-\\udfff\\ufffe\\uffff]|[?:-]<PLAIN>)(?:[ \t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*".replace(/<PLAIN>/g,(function(){return"[^\\s\\x00-\\x08\\x0e-\\x1f,[\\]{}\\x7f-\\x84\\x86-\\x9f\\ud800-\\udfff\\ufffe\\uffff]"})),d="\"(?:[^\"\\\\\r\n]|\\\\.)*\"|'(?:[^'\\\\\r\n]|\\\\.)*'";function o(e,n){n=(n||"").replace(/m/g,"")+"m";var r="([:\\-,[{]\\s*(?:\\s<<prop>>[ \t]+)?)(?:<<value>>)(?=[ \t]*(?:$|,|\\]|\\}|(?:[\r\n]\\s*)?#))".replace(/<<prop>>/g,(function(){return t})).replace(/<<value>>/g,(function(){return e}));return RegExp(r,n)}e.languages.yaml={scalar:{pattern:RegExp("([\\-:]\\s*(?:\\s<<prop>>[ \t]+)?[|>])[ \t]*(?:((?:\r?\n|\r)[ \t]+)\\S[^\r\n]*(?:\\2[^\r\n]+)*)".replace(/<<prop>>/g,(function(){return t}))),lookbehind:!0,alias:"string"},comment:/#.*/,key:{pattern:RegExp("((?:^|[:\\-,[{\r\n?])[ \t]*(?:<<prop>>[ \t]+)?)<<key>>(?=\\s*:\\s)".replace(/<<prop>>/g,(function(){return t})).replace(/<<key>>/g,(function(){return"(?:"+a+"|"+d+")"}))),lookbehind:!0,greedy:!0,alias:"atrule"},directive:{pattern:/(^[ \t]*)%.+/m,lookbehind:!0,alias:"important"},datetime:{pattern:o("\\d{4}-\\d\\d?-\\d\\d?(?:[tT]|[ \t]+)\\d\\d?:\\d{2}:\\d{2}(?:\\.\\d*)?(?:[ \t]*(?:Z|[-+]\\d\\d?(?::\\d{2})?))?|\\d{4}-\\d{2}-\\d{2}|\\d\\d?:\\d{2}(?::\\d{2}(?:\\.\\d*)?)?"),lookbehind:!0,alias:"number"},boolean:{pattern:o("false|true","i"),lookbehind:!0,alias:"important"},null:{pattern:o("null|~","i"),lookbehind:!0,alias:"important"},string:{pattern:o(d),lookbehind:!0,greedy:!0},number:{pattern:o("[+-]?(?:0x[\\da-f]+|0o[0-7]+|(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:e[+-]?\\d+)?|\\.inf|\\.nan)","i"),lookbehind:!0},tag:r,important:n,punctuation:/---|[:[\]{}\-,|>?]|\.\.\./},e.languages.yml=e.languages.yaml}(Prism);
                    </script>
                    <script>
                        (async function() {

                            const CURRENT_URL = document.currentScript? new URL(document.currentScript.src) : null;

                            if (!window.Bliss) {
                                // Load Bliss if not loaded
                                console.log("Bliss not loaded. Loading remotely from blissfuljs.com");

                                let bliss = document.createElement("script");
                                bliss.src = "https://blissfuljs.com/bliss.shy.min.js";
                                document.head.appendChild(bliss);

                                await new Promise(resolve => bliss.onload = resolve);
                            }

                            var $ = Bliss, $$ = Bliss.$;
                            var ready = Promise.resolve();

                            if (CURRENT_URL) {
                                // Tiny dynamic loader. Use e.g. ?load=css,markup,javascript to load components
                                var load = CURRENT_URL.searchParams.get("load");

                                if (load !== null) {
                                    var files = ["../prism-live.css"];

                                    if (load) {
                                        files.push(...load.split(/,/).map(c => /\./.test(c)? c : `prism-live-${c}.js`));
                                    }

                                    ready = Promise.all(files.map(url => $.load(url, CURRENT_URL)));
                                }
                            }

                            var superKey = navigator.platform.indexOf("Mac") === 0? "metaKey" : "ctrlKey";

                            var _ = Prism.Live = class PrismLive {
                                constructor(source) {
                                    this.source = source;
                                    this.sourceType = source.nodeName.toLowerCase();

                                    this.wrapper = $.create({
                                        className: "prism-live",
                                        around: this.source
                                    });

                                    if (this.sourceType === "textarea") {
                                        this.textarea = this.source;
                                        this.code = $.create("code");

                                        this.pre = $.create("pre", {
                                            className: this.textarea.className + " no-whitespace-normalization",
                                            contents: this.code,
                                            before: this.textarea
                                        });
                                    }
                                    else {
                                        this.pre = this.source;
                                        // Normalize once, to fix indentation from markup and then remove normalization
                                        // so we can enter blank lines etc

                                        // Prism.plugins.NormalizeWhitespace.normalize($("code", this.pre), {});
                                        this.pre.classList.add("no-whitespace-normalization");
                                        this.code = $("code", this.pre);

                                        this.textarea = $.create("textarea", {
                                            className: this.pre.className,
                                            value: this.pre.textContent,
                                            after: this.pre
                                        });
                                    }

                                    _.all.set(this.textarea, this);
                                    _.all.set(this.pre, this);
                                    _.all.set(this.code, this);

                                    this.pre.classList.add("prism-live");
                                    this.textarea.classList.add("prism-live");
                                    this.source.classList.add("prism-live-source");

                                    if (self.Incrementable) {
                                        // TODO data-* attribute for modifier
                                        // TODO load dynamically if not present
                                        new Incrementable(this.textarea);
                                    }

                                    $.bind(this.textarea, {
                                        input: evt => this.update(),

                                        keyup: evt => {
                                            if (evt.key == "Enter") { // Enter
                                                // Maintain indent on line breaks
                                                this.insert(this.currentIndent);
                                                this.syncScroll();
                                            }
                                        },

                                        keydown: evt => {
                                            if (evt.key == "Tab" && !evt.altKey) {
                                                // Default is to move focus off the textarea
                                                // this is never desirable in an editor
                                                evt.preventDefault();

                                                if (this.tabstops && this.tabstops.length > 0) {
                                                    // We have tabstops to go
                                                    this.moveCaret(this.tabstops.shift());
                                                }
                                                else if (this.hasSelection) {
                                                    var before = this.beforeCaret("\n");
                                                    var outdent = evt.shiftKey;

                                                    this.selectionStart -= before.length;

                                                    var selection = _.adjustIndentation(this.selection, {
                                                        relative: true,
                                                        indentation: outdent? -1 : 1
                                                    });

                                                    this.replace(selection);

                                                    if (outdent) {
                                                        var indentStart = _.regexp.gm`^${this.indent}`;
                                                        var isBeforeIndented = indentStart.test(before);
                                                        this.selectionStart += before.length + 1 - (outdent + isBeforeIndented);
                                                    }
                                                    else { // Indent
                                                        var hasLineAbove = before.length == this.selectionStart;
                                                        this.selectionStart += before.length + 1 + !hasLineAbove;
                                                    }
                                                }
                                                else {
                                                    // Nothing selected, expand snippet
                                                    var selector = _.match(this.beforeCaret(), /\S*$/);
                                                    var snippetExpanded = this.expandSnippet(selector);

                                                    if (snippetExpanded) {
                                                        requestAnimationFrame(() => $.fire(this.textarea, "input"));
                                                    }
                                                    else {
                                                        this.insert(this.indent);
                                                    }
                                                }
                                            }
                                            else if (_.pairs[evt.key]) {
                                                var other = _.pairs[evt.key];
                                                this.wrapSelection({
                                                    before: evt.key,
                                                    after: other,
                                                    outside: true
                                                });
                                                evt.preventDefault();
                                            }
                                            else if (Object.values(_.pairs).includes(evt.key)) {
                                                if (this.selectionStart == this.selectionEnd && this.textarea.value[this.selectionEnd] == evt.key) {
                                                    this.selectionStart += 1;
                                                    this.selectionEnd += 1;
                                                    evt.preventDefault();
                                                }
                                            }
                                            else {
                                                for (let shortcut in _.shortcuts) {
                                                    if (_.checkShortcut(shortcut, evt)) {
                                                        _.shortcuts[shortcut].call(this, evt);
                                                        evt.preventDefault();
                                                    }
                                                }
                                            }
                                        },

                                        click: evt => {
                                            var l = this.getLine();
                                            var v = this.value;
                                            var ss = this.selectionStart;
                                            //console.log(ss, v[ss], l, v.slice(l.start, l.end));
                                        },

                                        "click keyup": evt => {
                                            if (!evt.key || evt.key.lastIndexOf("Arrow") > -1) {
                                                // Caret moved
                                                this.tabstops = null;
                                            }
                                        }
                                    });

                                    // this.syncScroll();
                                    this.textarea.addEventListener("scroll", this, {passive: true});

                                    $.bind(window, {
                                        "resize": evt => this.syncStyles()
                                    });

                                    // Copy styles with a delay
                                    requestAnimationFrame(() => {
                                        this.syncStyles();

                                        var sourceCS = getComputedStyle(this.source);

                                        this.pre.style.height = this.source.style.height || sourceCS.getPropertyValue("--height");
                                        this.pre.style.maxHeight = this.source.style.maxHeight || sourceCS.getPropertyValue("--max-height");
                                        this.textarea.spellcheck = this.source.spellcheck || sourceCS.getPropertyValue("--spellcheck");
                                    });

                                    this.update();
                                    this.lang = (this.code.className.match(/lang(?:uage)?-(\w+)/i) || [,])[1];

                                    this.observer = new MutationObserver(r => {
                                        if (document.activeElement !== this.textarea) {
                                            this.textarea.value = this.pre.textContent;
                                        }
                                    });

                                    this.observe();

                                    this.source.dispatchEvent(new CustomEvent("prism-live-init", {bubbles: true, detail: this}));
                                }

                                handleEvent(evt) {
                                    if (evt.type === "scroll") {
                                        this.syncScroll();
                                    }
                                }

                                observe () {
                                    return this.observer && this.observer.observe(this.pre, {
                                        childList: true,
                                        subtree: true,
                                        characterData: true
                                    });
                                }

                                unobserve () {
                                    if (this.observer) {
                                        this.observer.takeRecords();
                                        this.observer.disconnect();
                                    }
                                }

                                expandSnippet(text) {
                                    if (!text) {
                                        return false;
                                    }

                                    var context = this.context;

                                    if (text in context.snippets || text in _.snippets) {
                                        // Static Snippets
                                        var expansion = context.snippets[text] || _.snippets[text];
                                    }
                                    else if (context.snippets.custom) {
                                        var expansion = context.snippets.custom.call(this, text);
                                    }

                                    if (expansion) {
                                        // Insert snippet
                                        var stops = [];
                                        var replacement = [];
                                        var str = expansion;
                                        var match;

                                        while (match = _.CARET_INDICATOR.exec(str)) {
                                            stops.push(match.index + 1);
                                            replacement.push(str.slice(0, match.index + match[1].length));
                                            str = str.slice(match.index + match[0].length);
                                            _.CARET_INDICATOR.lastIndex = 0;
                                        }

                                        replacement.push(str);
                                        replacement = replacement.join("");

                                        if (stops.length > 0) {
                                            // make first stop relative to end, all others relative to previous stop
                                            stops[0] -= replacement.length;
                                        }

                                        this.delete(text);
                                        this.insert(replacement, {matchIndentation: true});
                                        this.tabstops = stops;
                                        this.moveCaret(this.tabstops.shift());
                                    }

                                    return !!expansion;
                                }

                                get selectionStart() {
                                    return this.textarea.selectionStart;
                                }
                                set selectionStart(v) {
                                    this.textarea.selectionStart = v;
                                }

                                get selectionEnd() {
                                    return this.textarea.selectionEnd;
                                }
                                set selectionEnd(v) {
                                    this.textarea.selectionEnd = v;
                                }

                                get hasSelection() {
                                    return this.selectionStart != this.selectionEnd;
                                }

                                get selection() {
                                    return this.value.slice(this.selectionStart, this.selectionEnd);
                                }

                                get value() {
                                    return this.textarea.value;
                                }
                                set value(v) {
                                    this.textarea.value = v;
                                }

                                get indent() {
                                    return _.match(this.value, /^[\t ]+/m, _.DEFAULT_INDENT);
                                }

                                get currentIndent() {
                                    var before = this.value.slice(0, this.selectionStart-1);
                                    return _.match(before, /^[\t ]*/mg, "", -1);
                                }

                                // Current language at caret position
                                get currentLanguage() {
                                    var node = this.getNode();
                                    node = node? node.parentNode : this.code;
                                    var lang = _.match(node.closest('[class*="language-"]').className, /language-(\w+)/, 1);
                                    return _.aliases[lang] || lang;
                                }

                                // Get settings based on current language
                                get context() {
                                    var lang = this.currentLanguage;
                                    return _.languages[lang] || _.languages.DEFAULT;
                                }

                                setSelection(start, end) {
                                    if (start && typeof start === "object" && (start.start || start.end)) {
                                        end = start.end;
                                        start = start.start;
                                    }

                                    let prevStart = this.selectionStart;
                                    let prevEnd = this.selectionEnd;

                                    if (start !== undefined) {
                                        this.selectionStart = start;
                                    }

                                    if (end !== undefined) {
                                        this.selectionEnd = end;
                                    }

                                    // If there is a selection, and it's not the same as the previous selection, fire appropriate select event
                                    if (this.selectionStart !== this.selectionEnd && (prevStart !== this.selectionStart || prevEnd !== this.selectionEnd)) {
                                        this.textarea.dispatchEvent(new Event("select", {bubbles: true}));
                                    }
                                }

                                update (force) {
                                    var code = this.value;

                                    // If code ends in newline then browser "conveniently" trims it
                                    // but we want to see the new line we just inserted!
                                    // So we insert a zero-width space, which isn't trimmed
                                    if (/\n$/.test(this.value)) {
                                        code += "\u200b";
                                    }

                                    if (!force && this.code.textContent === code && $(".token", this.code)) {
                                        // Already highlighted
                                        return;
                                    }

                                    this.unobserve();
                                    this.code.textContent = code;

                                    Prism.highlightElement(this.code);

                                    this.observe();
                                }

                                syncStyles() {
                                    // Copy pre metrics over to textarea
                                    var cs = getComputedStyle(this.pre);

                                    // Copy styles from <pre> to textarea
                                    this.textarea.style.caretColor = cs.color;

                                    var properties = /^(font|lineHeight)|[tT]abSize/gi;

                                    for (var prop in cs) {
                                        if (cs[prop] && prop in this.textarea.style && properties.test(prop)) {
                                            this.wrapper.style[prop] = cs[prop];
                                            this.textarea.style[prop] = this.pre.style[prop] = "inherit";
                                        }
                                    }

                                    // This is primarily for supporting the line-numbers plugin.
                                    this.textarea.style['padding-left'] = cs['padding-left'];

                                    this.update();
                                }

                                syncScroll() {
                                    if (this.pre.clientWidth === 0 && this.pre.clientHeight === 0) {
                                        return;
                                    }

                                    this.pre.scrollTop = this.textarea.scrollTop;
                                    this.pre.scrollLeft = this.textarea.scrollLeft;
                                }

                                beforeCaretIndex (until = "") {
                                    return this.value.lastIndexOf(until, this.selectionStart);
                                }

                                afterCaretIndex (until = "") {
                                    return this.value.indexOf(until, this.selectionEnd);
                                }

                                beforeCaret (until = "") {
                                    var index = this.beforeCaretIndex(until);

                                    if (index === -1 || !until) {
                                        index = 0;
                                    }

                                    return this.value.slice(index, this.selectionStart);
                                }

                                getLine(offset = this.selectionStart) {
                                    var value = this.value;
                                    var lf = "\n", cr = "\r";
                                    var start, end, char;

                                    for (var start = this.selectionStart; char = value[start]; start--) {
                                        if (char === lf || char === cr || !start) {
                                            break;
                                        }
                                    }

                                    for (var end = this.selectionStart; char = value[end]; end++) {
                                        if (char === lf || char === cr) {
                                            break;
                                        }
                                    }

                                    return {start, end};
                                }

                                afterCaret(until = "") {
                                    var index = this.afterCaretIndex(until);

                                    if (index === -1 || !until) {
                                        index = undefined;
                                    }

                                    return this.value.slice(this.selectionEnd, index);
                                }

                                setCaret(pos) {
                                    this.selectionStart = this.selectionEnd = pos;
                                }

                                moveCaret(chars) {
                                    if (chars) {
                                        this.setCaret(this.selectionEnd + chars);
                                    }
                                }

                                insert(text, {index} = {}) {
                                    if (!text) {
                                        return;
                                    }

                                    this.textarea.focus();

                                    if (index === undefined) {
                                        // No specified index, insert in current caret position
                                        this.replace(text);
                                    }
                                    else {
                                        // Specified index, first move caret there
                                        var start = this.selectionStart;
                                        var end = this.selectionEnd;

                                        this.selectionStart = this.selectionEnd = index;
                                        this.replace(text);

                                        this.setSelection(
                                            start + (index < start? text.length : 0),
                                            end + (index <= end? text.length : 0)
                                        );
                                    }
                                }

                                // Replace currently selected text
                                replace (text) {
                                    var hadSelection = this.hasSelection;

                                    this.insertText(text);

                                    if (hadSelection) {
                                        // By default inserText places the caret at the end, losing any selection
                                        // What we want instead is the replaced text to be selected
                                        this.setSelection({start: this.selectionEnd - text.length});
                                    }
                                }

                                // Set text between indexes and restore caret position
                                set (text, {start, end} = {}) {
                                    var ss = this.selectionStart;
                                    var se = this.selectionEnd;

                                    this.setSelection(start, end);

                                    this.insertText(text);

                                    this.setSelection(ss, se);
                                }

                                insertText (text) {
                                    if (!text) {
                                        return;
                                    }

                                    if (_.supportsExecCommand === true) {
                                        document.execCommand("insertText", false, text);
                                    }
                                    else if (_.supportsExecCommand === undefined) {
                                        // We still don't know if document.execCommand("insertText") is supported
                                        let value = this.value;

                                        document.execCommand("insertText", false, text);

                                        _.supportsExecCommand = value !== this.value;
                                    }

                                    if (_.supportsExecCommand === false) {
                                        this.textarea.setRangeText(text, this.selectionStart, this.selectionEnd, "end");
                                        requestAnimationFrame(() => this.update());
                                    }

                                    return _.supportsExecCommand;
                                }

                                /**
                                 * Wrap text with strings
                                 * @param before {String} The text to insert before
                                 * @param after {String} The text to insert after
                                 * @param start {Number} Character offset
                                 * @param end {Number} Character offset
                                 */
                                wrap ({before, after, start = this.selectionStart, end = this.selectionEnd} = {}) {
                                    var ss = this.selectionStart;
                                    var se = this.selectionEnd;
                                    var between = this.value.slice(start, end);

                                    this.set(before + between + after, {start, end});

                                    if (ss > start) {
                                        ss += before.length;
                                    }

                                    if (se > start) {
                                        se += before.length;
                                    }

                                    if (ss > end) {
                                        ss += after.length;
                                    }

                                    if (se > end) {
                                        se += after.length;
                                    }

                                    this.setSelection(ss, se);
                                }

                                wrapSelection (o = {}) {
                                    var hadSelection = this.hasSelection;

                                    this.replace(o.before + this.selection + o.after);

                                    if (hadSelection) {
                                        if (o.outside) {
                                            // Do not include new text in selection
                                            this.selectionStart += o.before.length;
                                            this.selectionEnd -= o.after.length;
                                        }
                                    }
                                    else {
                                        this.moveCaret(-o.after.length);
                                    }
                                }

                                toggleComment() {
                                    var comments = this.context.comments;

                                    // Are we inside a comment?
                                    var node = this.getNode();
                                    var commentNode = node.parentNode.closest(".token.comment");

                                    if (commentNode) {
                                        // Remove comment
                                        var start = this.getOffset(commentNode);
                                        var commentText = commentNode.textContent;

                                        if (comments.singleline && commentText.indexOf(comments.singleline) === 0) {
                                            var end = start + commentText.length;
                                            this.set(this.value.slice(start + comments.singleline.length, end), {start, end});
                                            this.moveCaret(-comments.singleline.length);
                                        }
                                        else {
                                            comments = comments.multiline || comments;
                                            var end = start + commentText.length - comments[1].length;
                                            this.set(this.value.slice(start + comments[0].length, end), {start, end: end + comments[1].length});
                                        }
                                    }
                                    else {
                                        // Not inside comment, add
                                        if (this.hasSelection) {
                                            comments = comments.multiline || comments;

                                            this.wrapSelection({
                                                before: comments[0],
                                                after: comments[1]
                                            });
                                        }
                                        else {
                                            // No selection, wrap line
                                            // FIXME *inside indent*
                                            comments = comments.singleline? [comments.singleline, ""] : comments.multiline || comments;
                                            end = this.afterCaretIndex("\n");
                                            this.wrap({
                                                before: comments[0],
                                                after: comments[1],
                                                start: this.beforeCaretIndex("\n") + 1,
                                                end: end < 0? this.value.length : end
                                            });
                                        }
                                    }
                                }

                                duplicateContent () {
                                    var before = this.beforeCaret("\n");
                                    var after = this.afterCaret("\n");
                                    var text = before + this.selection + after;

                                    this.insert(text, {index: this.selectionStart - before.length});
                                }

                                delete (characters, {forward, pos} = {}) {
                                    var i = characters = characters > 0? characters : (characters + "").length;

                                    if (pos) {
                                        var selectionStart = this.selectionStart;
                                        this.selectionStart = pos;
                                        this.selectionEnd = pos + this.selectionEnd - selectionStart;
                                    }

                                    while (i--) {
                                        document.execCommand(forward? "forwardDelete" : "delete");
                                    }

                                    if (pos) {
                                        // Restore caret
                                        this.selectionStart = selectionStart - characters;
                                        this.selectionEnd = this.selectionEnd - pos + this.selectionStart;
                                    }
                                }

                                /**
                                 * Get the text node at a given chracter offset
                                 */
                                getNode(offset = this.selectionStart, container = this.code) {
                                    var node, sum = 0;
                                    var walk = document.createTreeWalker(container, NodeFilter.SHOW_TEXT);

                                    while (node = walk.nextNode()) {
                                        sum += node.data.length;

                                        if (sum >= offset) {
                                            return node;
                                        }
                                    }

                                    // if here, offset is larger than maximum
                                    return null;
                                }

                                /**
                                 * Get the character offset of a given node in the highlighted source
                                 */
                                getOffset(node) {
                                    var range = document.createRange();
                                    range.selectNodeContents(this.code);
                                    range.setEnd(node, 0);
                                    return range.toString().length;
                                }

                                // Utility method to get regex matches
                                static match(str, regex, def, index = 0) {
                                    if (typeof def === "number" && arguments.length === 3) {
                                        index = def;
                                        def = undefined;
                                    }

                                    var match = str.match(regex);

                                    if (index < 0) {
                                        index = match.length + index;
                                    }

                                    return match? match[index] : def;
                                }

                                static checkShortcut(shortcut, evt) {
                                    return shortcut.trim().split(/\s*\+\s*/).every(key => {
                                        switch (key) {
                                            case "Cmd":   return evt[superKey];
                                            case "Ctrl":  return evt.ctrlKey;
                                            case "Shift": return evt.shiftKey;
                                            case "Alt":   return evt.altKey;
                                            default: return evt.key === key;
                                        }
                                    });
                                }

                                static registerLanguage(name, context, parent = _.languages.DEFAULT) {
                                    Object.setPrototypeOf(context, parent);
                                    return _.languages[name] = context;
                                }

                                static matchIndentation(text, currentIndent) {
                                    // FIXME this assumes that text has no indentation of its own
                                    // to make this more generally useful beyond snippets, we should first
                                    // strip text's own indentation.
                                    text = text.replace(/\r?\n/g, "$&" + currentIndent);
                                }

                                static adjustIndentation(text, {indentation, relative = true, indent = _.DEFAULT_INDENT}) {
                                    if (!relative) {
                                        // First strip min indentation
                                        var minIndent = text.match(_.regexp.gm`^(${indent})+`).sort()[0];

                                        if (minIndent) {
                                            text.replace(_.regexp.gm`^${minIndent}`, "");
                                        }
                                    }

                                    if (indentation < 0) {
                                        return text.replace(_.regexp.gm`^${indent}`, "");
                                    }
                                    else if (indentation > 0) { // Indent
                                        return text.replace(/^/gm, indent);
                                    }
                                }

                                static create (source, ...args) {
                                    let ret = _.all.get(source);
                                    if (!ret) {
                                        ret = new _(source);
                                    }
                                    return ret;
                                }
                            };

// Static properties
                            Object.assign(_, {
                                all: new WeakMap(),
                                ready,
                                DEFAULT_INDENT: "\t",
                                CARET_INDICATOR: /(^|[^\\])\$(\d+)/g,
                                snippets: {
                                    "test": "Snippets work!",
                                },
                                pairs: {
                                    "(": ")",
                                    "[": "]",
                                    "{": "}",
                                    '"': '"',
                                    "'": "'",
                                    "`": "`"
                                },
                                shortcuts: {
                                    "Cmd + /": function() {
                                        this.toggleComment();
                                    },
                                    "Ctrl + Shift + D": function() {
                                        this.duplicateContent();
                                    }
                                },
                                languages: {
                                    DEFAULT: {
                                        comments: {
                                            multiline: ["/*", "*/"]
                                        },
                                        snippets: {}
                                    }
                                },
                                // Map of Prism language ids and their canonical name
                                aliases: (() => {
                                    var ret = {};
                                    var canonical = new WeakMap(Object.entries(Prism.languages).map(x => x.reverse()).reverse());

                                    for (var id in Prism.languages) {
                                        var grammar = Prism.languages[id];

                                        if (typeof grammar !== "function") {
                                            ret[id] = canonical.get(grammar);
                                        }
                                    }

                                    return ret;
                                })(),

                                regexp: (() => {
                                    var escape = s => s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
                                    var _regexp = (flags, strings, ...values) => {
                                        var pattern = strings[0] + values.map((v, i) => escape(v) + strings[i+1]).join("");
                                        return RegExp(pattern, flags);
                                    };
                                    var cache = {};

                                    return new Proxy(_regexp.bind(_, ""), {
                                        get: (t, property) => {
                                            return t[property] || cache[property]
                                                || (cache[property] = _regexp.bind(_, property));
                                        }
                                    });
                                })()
                            });

                            _.supportsExecCommand = document.execCommand? undefined : false;

                            $.ready().then(() => {
                                $$(":not(.prism-live) > textarea.prism-live, :not(.prism-live) > pre.prism-live").forEach(source => _.create(source));
                            });

                        })();

                    </script>

                    <form action="" method="post">
                        <p><b>Введите ваш говнокод:</b></p>
                        <a href="#" onclick="" class="btn btn-success btn-icon-split">
                                        <span class="icon text-white-50">
                                            <i class="fas fa-check"></i>
                                        </span>
                            <span class="text">Отправить</span>
                        </a>
                        <textarea spellcheck="false" class="prism-live language-html" name="text"></textarea>
                    </form>
                </div>
                <!-- End of Main Content -->

                <!-- Footer -->
                <footer class="sticky-footer bg-white">
                    <div class="container my-auto">
                        <div class="copyright text-center my-auto">
                            <span>Copyright &copy; Your Website 2021</span>
                        </div>
                    </div>
                </footer>
                <!-- End of Footer -->

            </div>
            <!-- End of Content Wrapper -->

        </div>
        <!-- End of Page Wrapper -->

        <!-- Scroll to Top Button-->
        <a class="scroll-to-top rounded" href="#page-top">
            <i class="fas fa-angle-up"></i>
        </a>

        <!-- Logout Modal-->
        <div class="modal fade" id="logoutModal" tabindex="-1" role="dialog" aria-labelledby="exampleModalLabel"
             aria-hidden="true">
            <div class="modal-dialog" role="document">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="exampleModalLabel">Ready to Leave?</h5>
                        <button class="close" type="button" data-dismiss="modal" aria-label="Close">
                            <span aria-hidden="true">×</span>
                        </button>
                    </div>
                    <div class="modal-body">Select "Logout" below if you are ready to end your current session.</div>
                    <div class="modal-footer">
                        <button class="btn btn-secondary" type="button" data-dismiss="modal">Cancel</button>
                        <a class="btn btn-primary" href="login">Logout</a>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
    <!-- Bootstrap core JavaScript-->
    <script src="../static/vendor/jquery/jquery.min.js"></script>
    <script src="../static/vendor/bootstrap/js/bootstrap.bundle.min.js"></script>

    <!-- Core plugin JavaScript-->
    <script src="../static/vendor/jquery-easing/jquery.easing.min.js"></script>

    <!-- Custom scripts for all pages-->
    <script src="../static/js/sb-admin-2.min.js"></script>


</body>

</html>